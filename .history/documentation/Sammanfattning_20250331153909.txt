Toppen. Jag kommer att ta fram en noggrann och teknisk sammanställning av hela projektet från grenen `frontier-1.0` i `SimB-commits/Servicedrive-2.0`.

Sammanställningen kommer att inkludera:
- Övergripande syfte och användningsområde
- Teknisk arkitektur (frontend, backend, databas, API, mm.)
- Katalog- och filstruktur med beskrivningar
- Kodexempel där det är relevant
- Viktiga beroenden och tekniska val
- Så att en LLM kan fatta informerade beslut om vidareutveckling

Jag meddelar dig så snart sammanställningen är klar.

# Servicedrive 2.0 – Teknisk sammanställning

## Övergripande syfte och användningsområde 
Servicedrive 2.0 är ett **ärendehanteringssystem** (ticket management system) för små till mellanstora företag. Systemet låter företag hantera kundärenden (supportärenden, serviceärenden etc.) i en centraliserad webbapplikation. Målet är att erbjuda en plattform som kan växa med företaget – från en enkel gratisversion upp till mer avancerade betalversioner med utökad funktionalitet. I gratisversionen kan ett litet företag hantera basala ärenden (med t.ex. två egna ärendetyper och enkel statusuppföljning), medan högre betalnivåer inkluderar funktioner som **automatiserad kundkontakt via e-post och SMS**, bokning av tider, chattfunktionalitet samt statistik över ärendehanteringen ([github.com](https://github.com/SimB-commits/Servicedrive-2.0/raw/refs/heads/frontier-1.0/documentation/scope.txt#:~:text=Vad%20%C3%A4r%20servicedrive%3F%20Servicedrive%20%C3%A4r,Versioner)) ([github.com](https://github.com/SimB-commits/Servicedrive-2.0/raw/refs/heads/frontier-1.0/documentation/scope.txt#:~:text=p%C3%A5g%C3%A5ende%20och%20f%C3%A4rdiga%20%C3%A4renden%20Betalniv%C3%A5,Skapa%20o%C3%A4ndligt%20med)). Systemet stödjer även **flera användarroller** (t.ex. *Admin*, *Manager*, *User*) och möjliggör att en användare kan vara kopplad till flera organisationer eller butiker (*multi-tenant*, hanteras som *Store* i databasen). Detta innebär att samma användare kan arbeta med ärenden för olika enheter (t.ex. flera butiker) inom samma plattform. Sammanfattningsvis syftar Servicedrive 2.0 till att ge företag ett skalbart verktyg för att hålla ordning på kundärenden, från registrering och uppföljning till avslut, med möjlig integration av kundkommunikation och statistik.

## Teknisk arkitektur 
Servicedrive 2.0 är byggt som en **fullstack webbapplikation** med hjälp av *Next.js* (version 14/15) och *React*. Applikationen utnyttjar Next.js **Pages Router** (den traditionella `pages/`-strukturen) för att server-side rendera frontend-sidor och definiera API-endpoints för backendlogik ([Servicedrive-2.0/README.md at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/README.md#:~:text=Next)) ([Servicedrive-2.0/README.md at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/README.md#:~:text=How%20to%20Use)). Koden är skriven i **TypeScript** för ökad tydlighet och typsäkerhet, och projektet drar nytta av flera moderna webbramverk och bibliotek. Översiktligt kan arkitekturen delas upp i *frontend*-del, *backend*-del (API-logik) samt databaslager, med en gemensam kodbas genom Next.js.

### Frontend: Next.js, HeroUI och Tailwind  
Frontenden är en **React-baserad** applikation skapad med Next.js. Genom Next.js får man stöd för **Server-Side Rendering (SSR)** för bättre prestanda och SEO, samt möjlighet att definiera dynamiska routes för olika sidor ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=1.%20)) ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=,%C3%A4rendestatus%20och%20anv%C3%A4ndarroller)). Projektet använder Next.js pages-katalogen – t.ex. finns en sida för dashboard, sidor för att lista ärenden och kunder, formulär för nytt ärende etc. i `pages/`-strukturen. Den globala layouten och gemensamma komponenter injecteras via `_app.tsx` och `_document.tsx`. 

Till gränssnitt och design nyttjas **HeroUI** (v2), ett komponentbibliotek byggt ovanpå Tailwind CSS. HeroUI tillhandahåller färdiga UI-komponenter (knappar, formulärfält, navigationsmenyer m.m.) med konfigurerbara teman. Projektet inkluderar flera HeroUI-paket (t.ex. `@heroui/button`, `@heroui/input`, `@heroui/navbar` etc. samt kärnbiblioteket `@heroui/react` och `@heroui/theme` för temastöd) ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)) ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)). Tack vare HeroUI och **Tailwind CSS** blir det enkelt att bygga en enhetlig och responsiv design. Tailwind används i *utility-first*-stil för snabb styling av komponenter, och skräddarsys via konfiguration. I `tailwind.config.js` ser man t.ex. att alla komponent- och sidfiler skannas, att **dark mode** aktiveras (via klassen `class` på `<html>`-elementet), samt att HeroUIs tema-plugin integreras för att ge färdiga färgskalor och komponentstilar ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=content%3A%20)) ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=plugins%3A%20)). En utdrag ur konfigurationsfilen visar hur HeroUI kopplas in som plugin och mörkt tema aktiveras:

```js
// tailwind.config.js (utdrag)
const { heroui } = require("@heroui/theme");
module.exports = {
  content: ["./pages/**/*.{js,ts,jsx,tsx}", "./components/**/*.{js,ts,jsx,tsx}", ...],
  darkMode: "class",
  theme: { /* ... skräddarsydda färger, typsnitt etc ... */ },
  plugins: [
    heroui({ prefix: "heroui", defaultTheme: "light", /* ... */ })
  ]
};
``` 

Gränssnittet är komponentbaserat. I `components/`-katalogen finns återanvändbara React-komponenter för olika delar av appen, t.ex.: navigationsmenyer (`navbar.tsx` för desktop och `MobileMenu.tsx` för mobilmeny), komponenter för att välja aktiv butik (`StoreSelector.tsx` för att byta “store”-kontext), modala dialoger för statusuppdateringar (`StatusModal.tsx` och `StatusConfirmationDialog.tsx`), flerstegskomponenter (`Stepper.tsx` för t.ex. guider eller formulär i flera steg), temaväxlare för mörkt/ljus läge (`theme-switch.tsx`), med mera. Man har separerat domänspecifika UI-delar i undermappar – exempelvis innehåller `components/customer/` komponenter relaterade till kundvyn, `components/tickets/` för ärendehantering (som specialiserade tabell- och filterkomponenter för ärendelistor), `components/email/` för e-postmallar osv. Detta gör koden mer strukturerad och underlättar återanvändning. 

Vid interaktioner används standard **React-konventioner**. Global state för t.ex. inloggad användare och valt företag hanteras huvudsakligen via NextAuth (se autentisering nedan) samt React Context där det behövs (teknikstacken nämner t.ex. användning av Context API för ärendestatusar och roller ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=,komponenter%20och%20dynamiska%20gr%C3%A4nssnitt))). För API-anrop och datahämtning från backend kan man använda antingen Next.js inbyggda funktioner (via `getServerSideProps`/`getStaticProps` eller direktanrop i komponenter) eller klientbibliotek. I rekommendationerna för stacken föreslogs **React Query** för caching av data från API:er ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=6.%20)), även om det inte är explicit i package.json. Vid formulärhantering var tanken att använda **React Hook Form** för robusta formulär (t.ex. för kund- och ärendeformulär) ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=,first%20CSS)), i kombination med validering via **Zod** – projektet har Zod installerat ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)) och kan använda detta för schema-/inputvalidering av formulärdata både i frontend och vid API-endpoints. Formulärkomponenter som t.ex. `CustomerForm.tsx` definierar fält för kundinformation och nyttjar ovan nämnda biblioteks enkelhet att hantera formulärstatus och valideringsfel.

Slutligen används **Framer Motion** (`framer-motion`) för att animera gränssnittet ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)) – t.ex. för mjuka övergångar eller expanderande/kollapsande element – vilket ger en mer dynamisk användarupplevelse utan att skriva tungrodd animeringskod från grunden. Biblioteket **Recharts** (`recharts`) finns också inkluderat ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)), vilket antyder att det finns eller planeras visualiseringar i form av diagram, exempelvis under statistikdelen för ärendenas hanteringstider eller antal ärenden per status.

### Backend: API-rutter och affärslogik 
Serverdelen av applikationen är integrerad direkt i Next.js via **API Routes**. Under `pages/api/` finns ett flertal endpoints som utgör applikationens REST-liknande API. Varje resurs har en egen mapp med en eller flera filer som hanterar HTTP-förfrågningar. De viktigaste API-resurserna inkluderar bland annat:

- **`/api/auth/`** – hantering av autentisering (inkl. NextAuth endpoints under `[...nextauth].ts`, samt en custom `signup.ts` för nyregistrering av användare).
- **`/api/customers/`** – hämta, skapa, uppdatera och ta bort kunder. Här finns t.ex. `index.ts` (GET för lista kunder, POST för att skapa ny kund) och `[id].ts` (GET/PUT/DELETE för enskild kund) ([Servicedrive-2.0/documentation/api/openapi.yaml at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/api/openapi.yaml#:~:text=%2Fapi%2Fcustomers%3A)) ([Servicedrive-2.0/documentation/api/openapi.yaml at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/api/openapi.yaml#:~:text=%2Fapi%2Fcustomers%2F)). Även batch-hantering finns (filen `batch-delete.ts` kan ta bort flera kunder i en anrop).
- **`/api/tickets/`** – liknande upplägg för ärenden (tickets): `index.ts` hanterar lista & skapande av ärenden ([Servicedrive-2.0/documentation/api/openapi.yaml at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/api/openapi.yaml#:~:text=%2Fapi%2Ftickets%3A)) ([Servicedrive-2.0/documentation/api/openapi.yaml at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/api/openapi.yaml#:~:text=post%3A)), `[id].ts` för att läsa/uppdatera/radera ett specifikt ärende ([Servicedrive-2.0/documentation/api/openapi.yaml at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/api/openapi.yaml#:~:text=%2Fapi%2Ftickets%2F)) ([Servicedrive-2.0/documentation/api/openapi.yaml at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/api/openapi.yaml#:~:text=put%3A)).
- **`/api/stores/`** – hantering av *Store* (olika företagskonton eller butiker). T.ex. kunna skapa ny *Store*, hämta användarens tillgängliga stores mm.
- **`/api/user/`** – hämta och uppdatera information om inloggad användare (t.ex. ändra lösenord, inställningar).
- **`/api/import/` och `/api/export/`** – för import/export av data (t.ex. import av kundregister eller export av ärenden till Excel/CSV). Projektet inkluderar bibliotek som **ExcelJS** och **PapaParse** ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)) ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)), vilka sannolikt används här för att hantera filinläsning och -generering.
- **`/api/mail/`** – funktioner för e-postutskick och e-postmallar. Finns stöd för att skicka e-post vid vissa triggers (t.ex. bekräftelse när ett nytt ärende skapas) genom SendGrids API. Även **`/api/webhooks/`** existerar, sannolikt för att hantera inkommande webhooks från tredjepart (t.ex. bekräftelse från SendGrid om att en domän verifierats eller att ett e-postmeddelande levererats).
- **`/api/search/`** – en sökendpoint för globala sökningar (t.ex. sök bland ärenden och kunder). I `utils/searchService.ts` definieras logiken för att söka i databasen utifrån nyckelord.
- **`/api/test/`** – möjligtvis för teständamål (ev. en plats att testa utskick av mail/SMS eller andra integrationsfunktioner under utveckling).

Varje API-route är en **Node.js-funktion** som exporteras (konventionellt med signatur `(req, res) => {...}` i Next 13/14, eller via `NextResponse` i middleware). Man följer typiskt Next.js-mönstret att särskilja metoder genom `req.method`. Kodbasen innehåller exempelvis i `pages/api/customers/index.ts` logik som kontrollerar om `req.method` är `"GET"` eller `"POST"` och anropar motsvarande funktion. Genom att placera backendlogiken i dessa API-rutter slipper man en separat server, och Next.js sköter att köra dem server-side på en Node-runtime. För tyngre uppgifter eller integrationer med tredje part som kräver mer kontroll nämner teknologivalen att ett separat **Node/Express** kan användas vid behov ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=2.%20)), men i nuläget tycks det mesta vara hanterat inom Next.js miljö.

**Affärslogiken** är strukturerad med hjälp av hjälpfunktioner i `utils/`-katalogen. Här finns *service*-liknande moduler som anropas från API-rutterna, vilket ger en separation mellan HTTP-handling och själva logiken. T.ex. har vi: 

- `utils/import-export.ts` som innehåller kod för att läsa in CSV/Excel-filer och konvertera dem till dataobjekt (via PapaParse/ExcelJS) samt att generera exportfiler.
- `utils/mail-service.ts` som kapslar logik för att skicka e-post (via **SendGrid**). API-nycklar för SendGrid anges via miljövariabler, och modulen använder `@sendgrid/mail` för att skicka transaktionsmail (t.ex. notis om nytt ärende) ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=%22%40react)). Här finns även funktioner för att hantera e-postmallar (ersätta variabler i malltext med aktuella värden, etc.).
- `utils/sendgridDomain.ts` som troligen hjälper till med att verifiera avsändardomäner hos SendGrid – i databasen finns modeller för *VerifiedDomain* och *SenderAddress* per store (mer om dessa nedan).
- `utils/searchService.ts` för sökfunktionen – kan bygga upp databasfrågor mot Prisma för att söka i flera tabeller (t.ex. både kundnamn, ärenderubrik, m.m.) och returnera matchande resultat.
- `utils/logger.ts` för central loggning (t.ex. wrapper kring `console.log` med nivåer eller timestamp).
- `utils.validation.ts` för valideringsregler (om ej Zod används fullt ut, kan egna enkla validatorer finnas här).
- `utils.authHelper.ts` och `utils.sessionHelper.ts` med stödfunktioner för autentisering – t.ex. funktion för att hasha lösenord med **bcryptjs** (som är installerat ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=))), eller hjälp att hämta nuvarande användarsession.

Backendet integrerar också mot externa tjänster. För **e-post** används som nämnt **SendGrid** (API-nyckel konfigureras i miljövariabler). För **SMS-utskick** och tvåfaktorsautentisering finns planer att använda **Twilio** – dokumentationen (`documentation/techstack.txt`) listar Twilio som SMS-leverantör ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=1.%20)). I koden finns en fil `twilio_2FA_recovery_code.txt` vilket antyder att man experimenterat med 2FA; dock syns inget Twilio-bibliotek i dependencies, så denna del är troligen under utveckling. Om det implementeras kan t.ex. *Twilio Verify* användas för SMS-koder. 

Integrationer hanteras eventuellt asynkront via **webhooks** – t.ex. kan *SendGrid Webhooks* posta tillbaka till `/api/webhooks` när en kund svarar på ett ärende via e-post (dessa meddelanden kan då infogas som *Message* i systemet). Även domänverifiering för avsändare (när en admin lägger till egen avsändaradress för e-postutskick) kan ske via webhook-svar från SendGrid. All denna logik är dock dold i util-funktioner och kräver korrekt konfiguration av API-nycklar i drift.

### Databasmodell och Prisma 
Servicedrive 2.0 använder en **relationsdatabas (PostgreSQL)** tillsammans med **Prisma ORM** för att lagra och hämta data. Databasschemat är definierat i `prisma/schema.prisma` och innehåller tabeller för alla viktiga entiteter i systemet. Prisma ger dessutom en typad klient (`@prisma/client`) som används i både API-rutter och NextAuth för att göra databasfrågor. Här är en översikt av de centrala modellerna i schemat och hur de hänger samman:

- **User** – representerar en användare av systemet. Varje användare har unika fält som `id` (UUID), `email` (unik), `password` (lagras hashad med bcrypt), samt `firstName`/`lastName` och en `role` som är en enum med värden **ADMIN**, **MANAGER** eller **USER** ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=enum%20UserRole%20)). User har relationer till andra modeller: en användare kan vara kopplad till flera *Store* via pivot-tabellen *UserStore*, och har även en eventuell *UserPreference*. I User-modellen ser man två fält `createdTickets` och `assignedTickets` som båda är listor av Ticket – detta är Prisma-relationsnamn som anger att en användare både kan skapa ärenden och tilldelas ärenden (fältet `Ticket.userId` sätts för skapare och `Ticket.assignedTo` för tilldelad ansvarig). Dessutom används Prisma för integration med NextAuth, så modellen inkluderar relationer till *Account* och *Session* (beskrivs nedan) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=accounts%20Account)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=session_state%20String%3F)).
- **Store** – representerar ett företag/konto eller en enhet (t.ex. en butik eller avdelning) som kan ha egna kunder och ärenden. Store har ett auto-inkrement `id` (integer) och fält som `name`, `company` (företagsnamn), `address` etc. En store har relationer: en lista av *UserStore* (vilka användare som hör till butiken), *Customer* (kunder kopplade till butiken), *Ticket* (ärenden för butiken), *TicketType* (definierade ärendetyper i butiken) samt *CustomerCard* (se nedan) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=model%20Store%20)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=users%20UserStore)). Store har också relationer för *SenderAddress* och *VerifiedDomain* – dessa används för e-postutskick (t.ex. om butiken lägger till en avsändaradress och verifierar en domän via SendGrid). Slutligen kan butiken ha *MailTemplateSettings* och *Setting* kopplade.
- **UserStore** – en pivot/tabell för **många-till-många**-relationen mellan User och Store. Varje UserStore har ett eget id och referenser `userId` och `storeId` ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=model%20UserStore%20)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=storeId%20Int)). Detta möjliggör att en användare kan tillhöra flera stores och att en store kan ha flera användare. Det finns en unik index `@@unique([userId, storeId])` för att förhindra dubletter.
- **Customer** – en kund tillhör en viss Store (`storeId`). Kundmodellen innehåller kontaktuppgifter: namn, adress, `email` (unik per store) etc. Här finns även booleska fält som `newsletter` (om kunden prenumererar på nyhetsbrev) och `loyal` (om det är en lojal kund). Viktigt är att modellen har `tickets` – alla ärenden associerade med kunden ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=dateOfBirth%20DateTime%3F)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=dynamicFields%20Json%3F%20%40default%28)). Det finns också ett JSON-fält `dynamicFields` som defaultas till "{}" – detta används för att lagra eventuella extra kundattribut dynamiskt i JSON-format (t.ex. medlemsnummer, kundkategori m.m. som kan variera). Kombinationen av `email`+`storeId` är unik ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=updatedAt%20DateTime%20%40updatedAt)), likaså finns fältet `externalId` för att hålla ett externt kund-ID (t.ex. från ett affärssystem) som också är unikt per store.
- **CustomerCard** – en modell snarlik Customer som innehåller kundinformation och är kopplad till Store, med skillnaden att den inte länkas direkt till User eller Ticket. *CustomerCard* kan tolkas som fördefinierade kundprofiler eller alternativa kontaktpersoner. Modellen innehåller fält för namn, kontaktuppgifter och även `dynamicFields` samt en flagga `isDefault` ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=email%20String%3F)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=%2F%2F%20Flagga%20f%C3%B6r%20om%20detta,kundkortet%20som%20ska%20vara%20f%C3%B6rvalt)). Denna modell skulle kunna användas för att skapa flera kontaktkort för en och samma kund (t.ex. om en kund har flera kontaktpersoner), men i dagsläget finns ingen explicit relation mellan CustomerCard och Customer i schemat. Istället är CustomerCard fristående per store. (Det kan vara under utveckling; eventuellt var tanken att ersätta Customer med CustomerCard helt och låta CustomerCard representera alla kundposter.)
- **Ticket** – representerar ett ärende. Varje Ticket har ett auto-ID (int) och fält som `title` (titel/rubrik), `description` (beskrivning), samt `status`. *Status*-fältet är en enum **TicketStatus** med grundläggande värden `OPEN`, `IN_PROGRESS`, `RESOLVED`, `CLOSED` ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=enum%20TicketStatus%20)), men dessutom finns möjlighet till *egendefinierade statusar* via fältet `customStatusId` kopplat till modellen *UserTicketStatus*. Ticket har relationer: det är kopplat till en *Customer* (kunden ärendet gäller) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=user%20User%20%40relation%28,id)), en *Store* (vilken enhet som hanterar ärendet) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=assignedTo%20String%3F)), en *TicketType* (kategori av ärendet, t.ex. Support, Retur, etc.) och två användare: dels `user` (den som skapade ärendet) och dels `assignedUser` (den som ärendet är för närvarande tilldelat, om någon) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=dynamicFields%20Json)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=assignedUser%20User%3F%20%40relation%28,id)). Ärendet kan också ha ett förväntat slutdatum `dueDate`. För att stödja flexibla fält har Ticket även ett JSON-fält `dynamicFields` – t.ex. om vissa ärendetyper kräver extra information kan dessa sparas här. Ticket har en lista av *Message*-objekt kopplade (alla meddelanden/kommentarer i ärendet).
- **TicketType** – definierar olika ärendekategorier inom en Store, t.ex. “Supportärende”, “Reparation”, “Retur” etc. TicketType har `id`, ett namn och referens till *Store*. Varje TicketType kan ha flera *TicketField* definierade och relateras till de Ticket records som har den typen ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=id%20Int%20%40id%20%40default)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=tickets%20Ticket)).
- **TicketField** – representerar ett extra fält som hör till en viss ärendetyp. T.ex. om TicketType är “Reparation” kan TicketField vara “Produktens serienummer”. Fältet har namn, en typ (enum **FieldType** med värden som TEXT, NUMBER, DATE, DUE_DATE m.m. för att indikera datatyp) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=name%20String)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=enum%20FieldType%20)), samt en flagga om det är obligatoriskt. TicketFields är kopplade till TicketType; idén är att när man skapar ett ärende av viss typ kan systemet begära in dessa extra fält och spara dem (troligen i Ticket.dynamicFields som matchar mot TicketField). Detta ger systemet flexibilitet att utökas utan databasändring för varje ny fälttyp.
- **UserTicketStatus** – den modell som möjliggör *egna statusar* för ärenden utöver de fasta i TicketStatus-enumen. Varje UserTicketStatus har ett namn (t.ex. “Väntar på kund”, “Del beställd”), en färgkod (hexvärde) för att kunna visas med färg i UI, samt koppling till *Store* ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=model%20UserTicketStatus%20)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=name%20String)). En UserTicketStatus kan kopplas till flera Ticket (relationen `tickets` är definierad med namn `"TicketCustomStatus"` i Ticket-modellen) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=assignedUser%20User%3F%20%40relation%28,id)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=updatedAt%20DateTime%20%40updatedAt)). Dessutom kan en UserTicketStatus kopplas till en viss *MailTemplate* (via `mailTemplateId`): detta innebär att om ett ärende sätts till den custom-statusen kan ett visst mail triggas. T.ex. en status “Resolved” kan kopplas till en “Ärende avslutat”-mall. 
- **Message** – varje Message motsvarar ett meddelande eller en notering i ett ärende, antingen från en användare eller från kunden (via e-post). Message har ett `content` (text), en `senderId` som är kopplad till en User (null om meddelandet kommer externt), samt referens till *Ticket* ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=senderId%20String%3F%20%2F%2F%20Anv%C3%A4ndaren%20som,null%20f%C3%B6r%20kundmeddelanden)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=ticket%20Ticket%20%40relation%28fields%3A%20,id)). För e-postintegration finns fält som `isFromCustomer` (bool, om meddelandet kom från kunden), samt fält för e-postmetadata: `emailFrom`, `emailTo`, `emailSubject`, `emailMessageId`, `emailInReplyTo`, `emailReferences`, `emailReplyTo`. Dessa används för att matcha ihop inkommande och utgående mail med rätt ärende och tråd. T.ex. när ett mail kommer in via webhook från SendGrid kan man titta på `In-Reply-To`-headern för att se vilket ärende det hör till. **Index** sätts på flera av dessa fält för prestanda ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=isFromCustomer%20Boolean%20%40default,om%20meddelandet%20kom%20fr%C3%A5n%20kunden)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=%2F%2F%20Indexera%20f%C3%B6r%20snabbare%20s%C3%B6kningar)). Genom Message-modellen kan systemet alltså fungera som en enkel ärendeinkorg – en administratör kan skriva ett svar som sparas som Message och skickas ut via e-post, och kundens svar på mailet kommer tillbaka och sparas som ett Message knutet till ärendet.
- **MailTemplate** – mallar för e-postutskick. Varje mall har ett namn, ett ämne (`subject`) och en brödtext (`body`), samt är kopplad till en Store (så varje företag kan ha sina egna mallar) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=id%20Int%20%40id%20%40default)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=updatedAt%20DateTime%20%40updatedAt)). Mallarna kan användas för olika ändamål, definierade av enum **MailTemplateUsage** (t.ex. NEW_TICKET – bekräftelse vid nytt ärende, STATUS_UPDATE – vid statusändring, REMINDER – påminnelser etc.) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=%2F%2F%20Definierar%20enum%20f%C3%B6r%20olika,anv%C3%A4ndningsomr%C3%A5den%20f%C3%B6r%20mailmallar)). Själva kopplingen mellan mallar och användning hanteras av modellen **MailTemplateSettings**.
- **MailTemplateSettings** – denna modell länkar en *Store* tillsammans med en viss usage (MailTemplateUsage) till en vald *MailTemplate*. Den har fälten `storeId`, `usage` och `templateId` (valfri – kan vara null om inget utskick ska ske för det fallet) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=id%20Int%20%40id%20%40default)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=template%20MailTemplate%3F%20%40relation%28fields%3A%20,id)). Genom en unik index `@@unique([storeId, usage])` försäkrar man att varje store har max en mall per användningsområde. I praktiken betyder detta att en administratör kan konfigurera t.ex. att för “Nytt ärende” ska mall X användas, för “Status uppdaterad” mall Y, etc.
- **SenderAddress** – lagrar e-postavsändare per Store. Varje SenderAddress har en e-postadress, ev. ett namn, och flaggan `isDefault` (om den ska användas som förvald avsändare) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=storeId%20Int)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=createdAt%20DateTime%20%40default)). Dessa adresser kan vara t.ex. företagets support-adress. Innan en adress används för utskick via SendGrid måste den (eller dess domän) vara verifierad.
- **VerifiedDomain** – lagrar domäner som är verifierade för e-postutskick. Fält inkluderar `domain` (t.ex. “example.com”), ett `domainId` (unikt ID från SendGrid för den domänen) samt status (pending, verified, failed) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=model%20VerifiedDomain%20)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=store%20Store%20%40relation%28fields%3A%20,id)). Den är kopplad till Store och används troligen för att visa i adminpanelen om företagets e-postdomän har blivit godkänd för att skicka e-post via tredjeparten.
- **Setting** – en enkel modell för nyckel/värde-inställningar per Store ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=model%20Setting%20)) ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=createdAt%20DateTime%20%40default)). Nyckeln `key` tillsammans med `storeId` är primärnyckel (unik kombination). Denna kan lagra diverse config som inte motiverar egen kolumn – t.ex. konfigurationsflaggor, inställningar om funktioner på/av, med mera.

Som synes är datamodellen rik och normaliserad. Prisma-klienten används i koden för att hämta och skriva data. Exempelvis i inloggningslogiken används `prisma.user.findUnique` för att slå upp användare efter email ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=%2F%2F%20Hitta%20anv%C3%A4ndaren%20i%20databasen)). Prisma gör det enkelt att följa relationer – t.ex. inkluderas `stores` och `preference` vid inloggning för att direkt veta vilka stores användaren tillhör och om han/hon har en vald favoritstore ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=where%3A%20)). Även i API-rutterna nyttjas Prisma, t.ex. för att lista kunder: `prisma.customer.findMany({ where: { storeId: ... } })` med paginering och filtrering om det stöds. Den typen av frågor kan genereras utifrån query-parametrar i API-anropen (t.ex. search, sortering). 

Prisma hanterar också migreringar – i projektet finns en `prisma/migrations/`-katalog med migreringsfiler som versionshanterar databasens schema. När schemat ändras (t.ex. ny modell eller fält) skapas en ny migrationsfil som kan köras mot databasen. Detta gör att man kan samarbeta och distribuera databasändringar på ett säkert sätt. För utveckling används vanligen kommandot `npx prisma migrate dev` för att applicera ändringar.

### Autentisering och middleware 
**Autentisering** implementeras med **NextAuth.js** (v4) i kombination med egen inloggningslogik via e-post/lösenord. NextAuth är konfigurerat med en **Credentials Provider**, vilket innebär att användaren loggar in genom att skicka sina inloggningsuppgifter som NextAuth sedan verifierar själv mot databasen ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=providers%3A%20)) ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=CredentialsProvider%28)). I filen `pages/api/auth/[...nextauth].ts` inkluderas inställningarna från `authOptions.ts` där NextAuth konfigureras. Nedan visas ett kodutdrag som illustrerar hur NextAuth är uppsatt för credentials-login:

```typescript
// Utdrag ur authOptions.ts – NextAuth konfiguration med CredentialsProvider
providers: [
  CredentialsProvider({
    name: "Credentials",
    credentials: { 
      email: { label: "Email", type: "text" },
      password: { label: "Password", type: "password" }
    },
    async authorize(credentials, req) {
      // Begränsa inloggningsförsök per IP
      const ip = req.headers["x-forwarded-for"]?.split(",")[0] || req.socket.remoteAddress || "";
      await loginRateLimiter.consume(ip);  // kastar fel om gräns nåtts
      // Hitta användare i databasen och jämför lösenord
      const user = await prisma.user.findUnique({ where: { email: credentials.email } });
      if (user && await bcrypt.compare(credentials.password, user.password)) {
        // Sätt aktiv store (om användaren har preferens, annars första tillgängliga)
        let storeId = user.preference?.selectedStoreId ?? user.stores[0]?.storeId;
        return { id: user.id, email: user.email, role: user.role, storeId };
      }
      throw new Error("INVALID_CREDENTIALS");  // ogiltig inloggning
    }
  })
],
// ... (cookies, session etc konfigureras automatiskt av NextAuth)
```

Som synes görs en manuell validering: användaren hämtas via Prisma och `bcrypt.compare` används för att kontrollera lösenordet ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=preference%3A%20true)) ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=)). Notera att man även inför en **Rate Limiter** på inloggningsförsöken. Med hjälp av paketet `rate-limiter-flexible` och Redis (via `ioredis`) kan man spärra upprepade inloggningsförsök från samma IP. I koden ovan anropas `loginRateLimiter.consume(ip)` innan lösenordsverifiering – om för många misslyckade försök skett under kort tid kastas ett fel `'RATE_LIMIT_EXCEEDED'` ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=%2F%2F%20Rate%20limiting)) ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=if%20,)). Detta skyddar mot bruteforce-attacker på inloggningen.

När authorize-funktionen returnerar ett användarobjekt anses inloggningen lyckad. NextAuth skapar då en *session* för användaren. Projektet använder NextAuth i **JWT-läge** (standard för Credentials Provider), vilket innebär att ingen sessionspost sparas i databasen för inloggningen – istället får klienten en krypterad JWT-cookie. Dock är Prisma Adapter (`@next-auth/prisma-adapter`) installerad ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=)) och NextAuths tabeller (*Account, Session, VerificationToken*) finns i schemat. Det tyder på att man skulle kunna stödja även OAuth-inloggningar eller e-postlänkar i framtiden. I nuläget sker dock all inloggning via egna credential-rutten och *Session*-tabellen används eventuellt inte aktivt. (Man kan ändå behålla Prisma-adaptern för att t.ex. utnyttja *VerificationToken* ifall man implementerar “glömt lösenord” via email med en engångslänk.)

**Registrering (sign up)** av nya användare hanteras separat via endpoint `pages/api/auth/signup.ts`. Den tar emot e-post, lösenord (och ev. namn) och skapar en ny User i databasen. Lösenordet hashas med bcrypt innan det sparas (bcryptjs är inkluderat för detta). Efter skapad användare kan man antingen automatinlogga eller låta frontend omdirigera till inloggningssidan – i projektet verkar man välja att direkt logga in användaren eller uppmana denne att logga in manuellt. 

För att skydda applikationens sidor och API:er används Next.js **Middleware**. I rotfilen **`middleware.ts`** finns logik som körs för varje begäran som träffar servern. Denna middleware använder NextAuths JWT-helper `getToken` för att kontrollera om användaren har en giltig inloggad token (d.v.s. om en NextAuth-session finns i cookien) ([Servicedrive-2.0/middleware.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/middleware.ts#:~:text=import%20,auth%2Fjwt)) ([Servicedrive-2.0/middleware.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/middleware.ts#:~:text=const%20token%20%3D%20await%20getToken%28,NEXTAUTH_SECRET)). Om *token* saknas och användaren försöker nå en skyddad route, omdirigeras han/hon automatiskt till inloggningssidan `/auth/login` ([Servicedrive-2.0/middleware.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/middleware.ts#:~:text=)). Middleware-filen definierar en lista med öppna sökvägar (`openPaths`) som inte kräver inloggning – det inkluderar bl.a. `/api/auth` (alla auth-APIer), samt sidorna under `/auth/` (login, signup, logout) och ev. en `/public` path för publika resurser ([Servicedrive-2.0/middleware.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/middleware.ts#:~:text=%2F%2F%20Lista%20%C3%B6ver%20%C3%B6ppna%20rutter,som%20inte%20kr%C3%A4ver%20autentisering)). Alla andra paths – såsom `/dashboard`, `/arenden`, `/kunder`, `/nytt-arende`, `/installningar` samt alla API-rutter under `/api/` – listas under `matcher` i konfigurationen ([Servicedrive-2.0/middleware.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/middleware.ts#:~:text=export%20const%20config%20%3D%20)) och skyddas därmed. Middleware-mönstret gör att skyddet är centraliserat; man behöver inte skriva separat logik i varje sida för att kolla session, utan oinloggade användare stoppas redan på begäransnivå. När `getToken` hittar en token (d.v.s. användaren är inloggad) släpps trafiken vidare (`NextResponse.next()`), och i API-rutterna kan man via `req.cookies` eller `getServerSession` få information om vem användaren är om nödvändigt.

Utöver inloggning/utloggning hanteras **behörighet** (authorization) genom användarrollen och affärsregler. T.ex. kan fältet `user.role` nyttjas i frontend för att visa admin-funktioner endast för admins. Mycket av behörighetskontrollen kan ligga implicit – t.ex. en vanlig användare kanske inte ens ser navigationslänkar till admin-sidor. Men på API-nivå bör man ändå kontrollera roller vid känsliga operationer. Det finns sannolikt logik i vissa API-endpoints för att säkerställa att t.ex. endast en ADMIN kan radera en *Store* eller ändra en annan användares roll. Man kan använda `session.user.role` (NextAuth inkluderar custom data från authorize-return, t.ex. vi returnerar `role` och `storeId` i JWT:n ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=return%20))) för att avgöra rättigheter. En Manager kanske har rätt att hantera ärenden och kunder i sin store, men inte lägga till nya användare, etc. Dessa affärsregler är något man får utläsa ur applikationens kontext och är utformade efter behoven i *scope*.

Sammanfattningsvis: autentisering sker med e-post/lösenord via NextAuth (JWT-baserad session), lösenord lagras säkert hashade, och hela appen skyddas av en middleware som kräver inloggning för att nå skyddade resurser. Rate limiting och (planerad) 2FA ökar säkerheten, och roller används för att skilja på vanliga användare och administratörer. 

## Katalog- och filstruktur 
Projektet är organiserat i en tydlig struktur med separata mappar för komponenter, sidor, API, utils etc. Här är en överblick av toppnivåns kataloger och viktiga filer:

- **`pages/`** – Innehåller alla Next.js-sidor och API-rutter. Underkatalogen `pages/api/` rymmer backend-endpoints (t.ex. `api/customers/`, `api/tickets/` osv. enligt beskrivningen ovan). Övriga sidor inkluderar bl.a.:
  - `pages/dashboard/` – översiktssida efter inloggning (dashboard med statistik och genvägar).
  - `pages/arenden/` – sidor för ärendehantering. T.ex. en lista över ärenden, eventuellt en undersida per ärende om det visas i egen vy.
  - `pages/kunder/` – sidor för kundhantering (kundlista).
  - `pages/nytt-arende.tsx` – sida med formulär för att registrera ett nytt ärende.
  - `pages/arendetyper/` och `pages/arendestatusar/` – adminsidor för att hantera egna ärendetyper och statusar.
  - `pages/mailmallar/` – sida för att hantera e-postmallar (visa, redigera mallar för utskick).
  - `pages/installningar/` – inställningssida (troligen för admin, hantera företagets kontoinställningar, avsändaradress etc).
  - `pages/auth/` – innehåller sidor för autentisering: `login.tsx` (inloggningsformulär), `signup.tsx` (registrering) och `logout.tsx`.
  - Roten `pages/index.tsx` visar startsidan (möjligen en välkomst- eller marketing-sida om man inte är inloggad, alternativt redirectar direkt till dashboard om inloggad).
  - `_app.tsx` och `_document.tsx` för global app-initialisering (t.ex. inkludera Tailwind CSS, NextAuth Provider för sessioner, ThemeProvider för mörkt tema via **next-themes**, etc.). Här kan global layout sättas, t.ex. en generell `<Layout>`-komponent som omger alla sidor (inkl. navbar).
  - `pages/session.tsx` – denna fil finns i listan; sannolikt en sida för att välja aktiv *store* om användaren har flera (d.v.s. “byt konto/butik”). Alternativt kan den vara relaterad till session-hantering/test.
  - `pages/sok.tsx` – en söksida där man kan göra en global sökning bland ärenden/kunder.
  - `pages/test-mail.tsx` – möjligen en testsida för att skicka test-mail (för utveckling eller debugging av email-funktion, kan ha använts under utveckling).

- **`components/`** – Alla återanvändbara React-komponenter. Som nämnts tidigare är dessa delvis organiserade i domänspecifika undermappar:
  - `components/customer/` – komponenter för kundmoduler, t.ex. formulär eller vyer för kundinformation.
  - `components/tickets/` – komponenter för ärenden, t.ex. tabell för ärendelista, filtreringskomponenter för status/kategori. (Dokumentation nämner t.ex. `TicketTable.tsx` och `TicketFilters.tsx` ([Servicedrive-2.0/documentation/componentStructure.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/componentStructure.txt#:~:text=match%20at%20L794%20TicketTable,En%20tabellkomponent%20specialiserad%20f%C3%B6r%20%C3%A4renden)).)
  - `components/email/` – komponenter relaterade till e-postmallar eller visning av meddelanden.
  - `components/ImportExport/` – komponenter för import/export-funktioner (kanske filuppladdningsdialog, progress).
  - `components/help/` – eventuellt hjälpsidor eller guider.
  - Utöver mapparna finns generella komponentfiler: `AccountSettings.tsx` (formulär för att ändra användarens profil/lösenord), `DashboardSettings.tsx` (widget för inställningar direkt på dashboard), `LogoutButton.tsx` (knapp för att logga ut), `MobileMenu.tsx` (hamburgarmeny för små skärmar), `StatusConfirmationDialog.tsx` & `StatusModal.tsx` (dialoger för att byta status på ärende), `Stepper.tsx` (flerstegsindikator), `StoreManager.tsx` (komponent för att hantera butiker/konton – kanske adminfunktion för att lägga till ny *Store* eller hantera användare i store), `StoreSelector.tsx` (dropdown för att byta aktiv store – synlig om användaren har flera), `icons.tsx` (samling av ikon-komponenter eller Heroicons import), `navbar.tsx` (huvudmenyn för desktop), `primitives.ts` (kanske samlar bas-UI-element/stilar, t.ex. en wrapper för HeroUI:s tema eller variant-funktioner), `theme-switch.tsx` (knapp att växla mörkt/ljus läge). 

- **`layouts/`** – Denna mapp innehåller layout-komponenter. T.ex. skulle det kunna finnas `AuthenticatedLayout.tsx` för sidor som kräver login (inkl. sidomeny, header etc), `UnauthenticatedLayout.tsx` för inloggnings-/registreringssidor (en enklare layout utan nav), eller specifika layoutkomponenter för olika sektioner. Layouts kan användas via Next.js custom App eller genom att wrapper i sidor.

- **`lib/`** – Hjälpbibliotek och initialisering. Här ligger t.ex. `lib/prisma.ts` som skapar en singleton-instans av Prisma-klienten (för att undvika att Next startar flera instanser vid HMR i dev) – standardmönster med `globalThis` används ofta. Dessutom finns `lib/rateLimiter.ts` och `lib/rateLimiterApi.ts` som sannolikt sätter upp konfigurationen för **rate-limiter-flexible** (en för allmänt bruk och en specifik för API?). De kan definiera Redis-klient via `ioredis` och skapa en RateLimiter med vissa poäng (för t.ex. 5 loginförsök per 15 min). Dessa används sedan i `utils/authHelper.ts` (t.ex. `loginRateLimiter` som vi såg i koden ovan).

- **`utils/`** – Hjälpfunktioner och service-lager (se detaljer i föregående sektion *Backend*). Här hittas bl.a. `authHelper.ts` (med bcrypt hash/verify, generering av JWT om man skulle behöva manuellt, etc), `dashboard.ts` (möjligen aggregerar statistik till dashboardsidan – t.ex. antal öppna ärenden, genomsnittlig svarstid, etc. via Prisma-frågor), `date-formatter.ts` (funktioner för datumformatering, t.ex. visa datum i svensk format), `field-matcher.ts` (kopplar dynamiska fält till värden – t.ex. tar TicketField definitioner och extraherar motsvarande värden ur Ticket.dynamicFields JSON), `import-export.ts`, `logger.ts`, `mail-service.ts`, `searchService.ts`, `sendgrid.ts` (möjligen wrapper kring @sendgrid/mail för att skicka e-post), `sendgridDomain.ts` (för att hantera domänverifiering via SendGrids API), `sessionHelper.ts` (t.ex. funktioner för NextAuth att serialisera/deserialisera session eller att byta aktiv store), `ticketStatusService.ts` (funktioner för att skapa/uppdatera *UserTicketStatus*, ev. koppla dem till mailmallar, eller hämta alla statusar – används på sidan för ärendestatusar), `validation.ts` (allmänna valideringsfunktioner). Dessa moduler importeras vid behov i API-rutter och sidor för att hålla komponenterna rena från affärslogik.

- **`prisma/`** – Innehåller Prisma-schemat `schema.prisma` ([Servicedrive-2.0/prisma/schema.prisma at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/prisma/schema.prisma#:~:text=model%20User%20)) och migreringsfiler under `prisma/migrations/`. Schemat definierar alla modeller (beskrivna ovan). I projektet finns också en `.env`-fil (okommiterad, men refererad i Prisma-config) där t.ex. `DATABASE_URL` anges för att Prisma ska veta anslutningen. 

- **`styles/`** – Innehåller globala stilmallar. T.ex. filen `globals.css` där Tailwinds bas- och utility-klasser importeras (Tailwind CSS integreras via PostCSS). Där kan också finnas custom CSS om något inte täcks av Tailwind. 

- **`types/`** – Egna TypeScript-definitioner. T.ex. om man utökar `NextAuth` för att inkludera extra fält i `session.user` (som `role` och `storeId`), kan man i `types/next-auth.d.ts` deklarera module augmentation för NextAuth. Här kan även finnas typer för vissa objekt (t.ex. en Type för ett formulärsteg, eller en union-typ för alla statusar inkl. custom). *typeRoots* är inställd att inkludera `./types` i `tsconfig.json` ([Servicedrive-2.0/tsconfig.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tsconfig.json#:~:text=)).

- **`Tests/`** – Innehåller enhetstester/integrationstester. Det finns en undermapp `api/` som troligen innehåller tester för API-rutterna (t.ex. att skapa ärende, att behörighet fungerar – dessa kan använda **node-mocks-http** för att simulera `req`/`res`-objekt då det biblioteket är installerat ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=))). Det finns också `Tests/setupTests.ts` som laddas innan testsviten körs (konfigurerat i vitest.config). Där kan man importera `@testing-library/jest-dom/extend-expect` för bättre assertions i DOM, sätta upp globala fetch-mock eller liknande. Tests-katalogen är inkluderad i tsconfig för att få typing även där ([Servicedrive-2.0/tsconfig.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tsconfig.json#:~:text=)).

- **Övriga rotfiler**: `.eslintrc.json` (ESLint-konfiguration, inkluderar regler för React, import order, prettier etc – man har bl.a. plugin för unused-imports och prettier integrerat ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=%22eslint))), `.eslintignore` (filer att ignorera vid lint), `.prettierrc` (kodformateringsregler om det finns), `next.config.js` (Next.js konfiguration – i detta projekt är den i princip default; dock finns utkommenterad kod för att sätta strikta säkerhetsheaders som Content-Security-Policy och HSTS för all trafik ([Servicedrive-2.0/next.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/next.config.js#:~:text=)) ([Servicedrive-2.0/next.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/next.config.js#:~:text=key%3A%20%27Strict))), `postcss.config.js` (laddar Tailwind CSS och autoprefixer, standard för Tailwind-projekt), `tailwind.config.js` (se ovan), `tsconfig.json` (TypeScript-konfiguration – projektet kör med `"strict": true` och modern ESNext moduler. Här finns även alias `@/*` som mappas till projektroten för bekväma importvägar ([Servicedrive-2.0/tsconfig.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tsconfig.json#:~:text=))), `vitest.config.ts` (konfiguration för testverktyget Vitest, se mer nedan).

## Konfigurationsfiler och inställningar 
Projektet innehåller flera viktiga konfigurationsfiler som säkerställer att verktyg och ramverk är rätt inställda:

- **Next.js konfiguration (`next.config.js`)** – Här kan man vanligtvis aktivera/deaktivera experimentella funktioner, ställa in proxy eller headers. I Servicedrive 2.0 är filen nästintill tom förutom att man (utkommenterat) förberett säkerhetsheaders. Man ser t.ex. en Content Security Policy ställas in till en sträng som endast tillåter resurser från samma domän och inga externa skript ([Servicedrive-2.0/next.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/next.config.js#:~:text=)). Även HSTS-header för strikt HTTPS ingår ([Servicedrive-2.0/next.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/next.config.js#:~:text=key%3A%20%27Strict)). Dessa rader är kommenterade med `/* ... */`, vilket tyder på att de kanske aktiveras i produktionsbyggde eller är under test. Att inkludera sådana headers ökar säkerheten (förhindrar t.ex. att externa skript laddas av misstag och säger åt browsern att bara använda HTTPS). Next.config innehåller även defaultinställningar från Next – t.ex. `reactStrictMode` true, etc., även om just det inte syns explicit här (Next 15 har det default). Inga custom webpack-inställningar eller env-injektioner noterades, vilket innebär att konfigurationen är ganska standard.

- **TypeScript-konfiguration (`tsconfig.json`)** – Här anges projektspecifika TS-inställningar. Viktiga bitar:
  - `"target": "es5"` men `"module": "esnext"` – Next.js kräver ESNext modules men target=ES5 för bred kompatibilitet (transpilerar nya features).
  - `"strict": true` – strikt typning är på, vilket är bra för att fånga fel.
  - `"paths": { "@/*": ["./*"] }` – en aliasinställning som gör att man i import-satser kan skriva t.ex. `import { loginRateLimiter } from "@/lib/rateLimiter"` istället för relativa sökvägar. `@` pekar på root-mappen ([Servicedrive-2.0/tsconfig.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tsconfig.json#:~:text=)).
  - `"typeRoots": ["./types", "./node_modules/@types"]` – inkluderar den egna `types/`-mappen så att t.ex. utökningar av NextAuths typer och andra custom .d.ts-filer tas med ([Servicedrive-2.0/tsconfig.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tsconfig.json#:~:text=)).
  - `"include": [...]` – listar vilka filer som ska tas med av kompilatorn. Här ser vi att även `Tests` inkluderas ([Servicedrive-2.0/tsconfig.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tsconfig.json#:~:text=)) samt en `scripts/createTestStore.js` (kanske ett skript för att snabbt skapa en testbutik i databasen för utveckling). `"exclude": ["node_modules"]` som brukligt.
  - Under `"types": ["vitest", "node"]` lägger man till Vitests typer globalt, vilket gör att `describe`, `it`, `expect` etc. inte ger fel i testfiler.
  
- **Tailwind-konfiguration (`tailwind.config.js`)** – Som tidigare nämnt definierar denna var Tailwind ska leta efter klasser (content paths inkluderar pages/, components/ och även HeroUIs paket) ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=content%3A%20)). Dark mode sätts till klassläge. Under `theme.extend` finns justeringar av t.ex. fontfamilj (här används CSS-variabler som sätts via HeroUI, t.ex. `--font-sans`), border-radius och skuggor anpassas något för designens behov ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=extend%3A%20)) ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=boxShadow%3A%20)). Tailwind-plugins: Här integreras **HeroUI’s Tailwind-plugin** via `heroui({...})`-anropet ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=plugins%3A%20)). Inställningarna för pluginet i filen definierar bl.a. prefix (man kan använda klasser som `heroui-btn` för HeroUI-komponenter), om standardfärger ska läggas till, default-teman etc. I konfigurationen ser vi t.ex. att `addCommonColors: false` – troligen för att inte krocka med egna färger – och att ett färgtema “light” definieras med flera nyanser för *default* och *primary* färger ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=themes%3A%20)) ([Servicedrive-2.0/tailwind.config.js at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/tailwind.config.js#:~:text=primary%3A%20)). Detta styr utseendet på HeroUI-komponenterna (knappar, etc.) i ljust läge, och HeroUI kan automatiskt hantera dark mode-varianter. Tailwind-konfigurationen möjliggör således en smidig teming av appen.

- **ESLint och Prettier** – `.eslintrc.json` innehåller sannolikt ett extendar av `"next/core-web-vitals"` (Next.js standard) och integrerar Prettier för kodstil. Dessutom, utifrån package.json, har man plugin *eslint-plugin-unused-imports* för att rensa oanvända importer och en regeluppsättning som förhindrar vissa kodluktar. Prettier gör att all kod formateras enhetligt (citationstecken, semikolon etc.). Dessa verktyg körs troligen via npm-skript eller en pre-commit hook för att upprätthålla kodkvalitet.

- **Vitest-konfiguration (`vitest.config.ts`)** – Här definieras inställningar för testkörning med Vitest. Man använder `defineConfig` där `test.environment` sätts till `"jsdom"` (så att React-komponenter kan testas i en låtsas-DOM) ([Servicedrive-2.0/vitest.config.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/vitest.config.ts#:~:text=test%3A%20)). `setupFiles` pekar på `Tests/setupTests.ts` vilket laddas före alla test (där kan t.ex. global.fetch mokas eller `expect` utökas) ([Servicedrive-2.0/vitest.config.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/vitest.config.ts#:~:text=environment%3A%20%27jsdom%27%2C%20%2F%2F%20Vi%20anv%C3%A4nder,manipulation%20i%20React)). `globals: true` innebär att man inte behöver importera `describe`, `it` och `expect` i varje testfil – de finns globalt (likt i Jest) ([Servicedrive-2.0/vitest.config.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/vitest.config.ts#:~:text=setupFiles%3A%20,l%C3%A4gger%20global%20config%20f%C3%B6r%20tester)). Detta gör testfilerna renare. Vitest-configen kan också ha alias samma som tsconfig (förmodligen hanterar den `@` alias). Sammantaget är testmiljön konfigurerad att efterlikna Jests upplevelse fast med Vitests fördelar (snabbhet och Vite-integration).

- **Miljövariabler** – Även om det inte är en specifik fil listad, så förtjänar det att nämnas att `.env.local` (eller liknande) används för att lagra känsliga uppgifter: databasanslutning (`DATABASE_URL`), hemlighet för NextAuth JWT (`NEXTAUTH_SECRET`), API-nycklar för SendGrid och Twilio (`SENDGRID_API_KEY`, `TWILIO_SID` etc.), eventuellt Cloudinary eller S3 credentials om filuppladdning fanns, m.m. Dessa variabler läses in av Next (Next läser `.env.local` automatiskt) och används i koden via `process.env`. T.ex. `process.env.NEXTAUTH_SECRET` används i `getToken`-anropet i middleware ([Servicedrive-2.0/middleware.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/middleware.ts#:~:text=import%20,auth%2Fjwt)) ([Servicedrive-2.0/middleware.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/middleware.ts#:~:text=const%20token%20%3D%20await%20getToken%28,NEXTAUTH_SECRET)). Variabler för klienten måste börja med `NEXT_PUBLIC_` för att exponeras, men de flesta i detta projekt är server-hemligheter.

## Viktiga beroenden och deras användning 
Projektets `package.json` listar många beroenden. Här är de viktigaste och vad de används till:

- **Next.js** (`"next": "^15.2.3"`) – Ramverket som utgör basen för appen, hanterar routing, SSR/SSG och bygger både frontend och backend i ett. Version 15 innebär senaste funktioner, dock används här pages-router (ej nya App Router). Next.js sköter också build-processen och en dev-server för lokal utveckling.
- **React** (`"react": 18.x` + `"react-dom"`) – Biblioteket för att bygga användargränssnitt i komponenter. React 18 används med funktionella komponenter och hooks. 
- **HeroUI** (`@heroui/*` paket) – Design- och komponentbibliotek. T.ex. `@heroui/react` innehåller komponentlogik, `@heroui/button`, `@heroui/input` etc. är specifika komponenter, `@heroui/theme` innehåller färdiga Tailwind-teman. Detta gör utvecklingen snabbare genom att man kan använda färdiga stiliserade komponenter istället för att skriva all Tailwind-klassning manuellt. HeroUI integreras med Tailwind (via plugin) och bidrar med ett modernt, responsivt utseende.
- **Tailwind CSS** (`tailwindcss`: v3) – CSS-ramverk för utility-klasser. Används för layout och styling i hela appen. Med Tailwind kan utvecklarna snabbt experimentera med design direkt i komponenternas JSX genom att lägga till klasser för färg, padding, gridsystem, osv. *tailwind-variants* (0.3.0) är också inkluderat – det är ett utility-bibliotek för att skapa återanvändbara variant-klasser (t.ex. olika storlekar eller utseenden för en komponent) på ett typesafe sätt.
- **NextAuth** (`next-auth`: v4) – Bibliotek för autentisering i Next.js. Det ger stöd för olika OAuth-leverantörer samt credentials. Här används det med credentials-provider och Prisma-adapter. NextAuth sköter sessionhantering (JWT-cookie), kryptering, uthämtning av användare via adaptern, och har färdiga endpoints (under `/api/auth/`) för t.ex. sign-in, sign-out, callback etc. Detta sparar mycket arbete jämfört med att implementera hela auth-flödet manuellt.
- **@next-auth/prisma-adapter** – Kopplar NextAuth till Prisma så att NextAuth kan läsa/skriva användare, sessions m.m. i databasen med Prisma. I vårt fall används främst för att NextAuth ska kunna skapa användare via `signup` och (om man skulle använt email-login) hantera token. 
- **Prisma Client** (`@prisma/client`: v6) – Prisma ORM:s klientbibliotek. Detta genereras utifrån schemat och låter oss göra typeriktig DB-access. Används i alla databasoperationer (ex. `prisma.user.findUnique`, `prisma.ticket.update` etc). Prisma abstraherar SQL-frågor och gör utvecklingen säkrare och snabbare.
- **PostgreSQL** (ej som npm-paket, men som underliggande databas) – PostgreSQL är databasmotorn projektet riktar sig mot (enligt rekommendationerna ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=,tj%C3%A4nster))). Under utveckling kan SQLite användas för enkelhet, men för produktion är Postgres trolig. Prisma hanterar kompatibilitet, så byter man DB ändrar man bara connection string.
- **bcryptjs** – Bibliotek för att hash- och verifiera lösenord. Används vid registrering för att skapa en hashad version av användarens lösenord, och vid inloggning för att jämföra inkommande lösenord med den hash som finns sparad ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=)) ([Servicedrive-2.0/pages/api/auth/authOptions.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/pages/api/auth/authOptions.ts#:~:text=if%20%28user%20%26%26%20await%20bcrypt,password%29%29)). Bcryptjs är en ren JavaScript-implementation av bcrypt-algoritmen.
- **SendGrid Mail** (`@sendgrid/mail`: v8) – Används för att skicka e-post från Node. Projektet använder SendGrid för automatiska mail (t.ex. bekräftelser och notifikationer) ([Servicedrive-2.0/documentation/techstack.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/techstack.txt#:~:text=1.%20)). Genom detta bibliotek kan servern posta e-post genom SendGrids API enkelt. Man sätter API-nyckel via `sendgrid.setApiKey()` och kan sedan anropa `sendgrid.send(msg)`. SendGrid hanterar i sin tur leveransen. (I `utils/mail-service.ts` finns troligen en funktion som tar en MailTemplate + data, generar ett mail och skickar med @sendgrid/mail.)
- **Twilio** – Även om Twilios egna paket ej syns, är Twilio planerat för SMS. Troligen skulle man lägga till `twilio` paket vid implementering av 2FA eller SMS-notifieringar. Twilio API:et skulle då användas liknande SendGrid, för att skicka ut bekräftelsekoder eller SMS-påminnelser. (Twilio nämns i dokumentationen, men implementationen är troligtvis ofullständig i nuläget.)
- **rate-limiter-flexible** – Ett paket för att hantera rate limiting (begränsa antal anrop). Det fungerar med olika backends (minne, Redis etc.). I projektet används det för att skydda specifikt inloggningsförsöken (som vi såg). Med hjälp av **ioredis** (Redis-klient bibliotek) ([Servicedrive-2.0/package.json at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/package.json#:~:text=%22intl)) kan man använda en Redis-server för att dela rate-limit data (så att limit gäller över flera instanser av servern om skalad). Rate-limiter-flexible gör det enkelt att t.ex. säga “max 5 försök per 15 minuter per IP”. Om gränsen överskrids returnerar den ett reject så att koden kan kasta fel och informera klienten (vilket i UI kan översättas till “För många misslyckade försök, vänta en stund”). Detta ökar säkerheten och stabiliteten.
- **ExcelJS** och **PapaParse** – Dessa används för import/export-funktionen. *ExcelJS* kan skapa och läsa **.xlsx** Excel-filer, vilket kan användas för att exportera t.ex. alla ärenden eller kunder till ett Exceldokument med flikar. *PapaParse* är ett snabbt CSV-verktyg som kan tolka uppladdade CSV-filer eller konvertera JSON till CSV-string. Tillsammans möjliggör de att admin kan importera kundlistor eller exportera rapporter via frontend-gränssnittet. Kod för detta finns i `utils/import-export.ts`.
- **Framer Motion** – Används i frontend för animeringar (t.ex. fade in/out komponenter, accordion-effekter). Framer Motion integrerar bra med React med en deklarativ API för animation. Ingen specifik referens i koden ovan, men närvaro i dependency tyder på att man animerar t.ex. modaler eller sidövergångar.
- **Recharts** – Bibliotek för diagram och grafer. Möjligen används på *Dashboard*-sidan för att visa statistik (t.ex. ett linjediagram över antal ärenden per dag, eller ett cirkeldiagram över ärenden per status). Recharts är lätt att integrera med React-data.
- **Zod** – Validerings- och schema-bibliotek. Kan användas både klient- och serverside för att definiera schema för data (t.ex. hur ett kundobjekt ska se ut) och sedan validera att inkommande data följer schemat. Detta ökar robustheten – API-endpoints kan returnera 400 om datan inte matchar schemat. Zod integrerar också med React Hook Form om det används för att validera formulär i realtid. Även i `utils/validation.ts` kan Zod användas under huven.
- **next-themes** – Bibliotek för att hantera mörkt/ljust tema i Next.js. Det ger en ThemeProvider som kan toggla klassen `dark` på `<html>` och spara användarens temaval i localStorage. I projektet används det via komponenten `theme-switch.tsx` och konfigureras förmodligen i `_app.tsx`. Detta gör det enkelt för användaren att byta utseende, och HeroUI/Tailwind hanterar sedan de olika färgerna via sina `dark:` klasser. 
- **Testing Libraries**: 
  - *Vitest* – JavaScript/TypeScript test-runner. Liknar Jest i syntax men snabbare genom Vite. Används för att köra alla tester under *Tests* mappen. 
  - *@testing-library/react* och *@testing-library/jest-dom* – Används för att testa React-komponenter på ett användarcentrerat sätt. Testing Library låter oss rendera komponenter i en JSDOM-miljö och göra queries som en användare (t.ex. “find button with text Submit and click it”). Jest-dom tillför extra matchers till `expect` för DOM-element (t.ex. `.toHaveTextContent`). I testmiljön är även *jsdom* och *node-mocks-http* närvarande: jsdom simulerar webbläsare, node-mocks-http kan användas för att testa API-rutter genom att skapa ett fejk `req` och `res` objekt och se vad som returneras. Dessa verktyg säkerställer att kritiska delar av systemet (inloggning, komponentrendering, API-logik) fungerar som avsett och att nya ändringar inte introducerar regressioner.

## Huvudsakliga komponenter och återanvändbara delar 
Servicedrive 2.0 är uppbyggt av ett antal kärnkomponenter och moduler som kan återanvändas och utgör tillsammans designmönstren i appen:

- **Navigationsmenyer** – Appen har en toppmeny eller sidomeny (`navbar.tsx`) som visas för inloggade användare. Den innehåller länkar till de huvudsakliga sektionerna (Dashboard, Ärenden, Kunder, Inställningar, osv.). För mobil används en separat `MobileMenu.tsx` som kanske slidar ut en meny. Dessa komponenter är utformade att vara återanvändbara över sidor och reflekterar vilken sida som är aktiv, visar eventuellt företagsnamn, och en användarmeny (med Logga ut-knapp, som återfinns i `LogoutButton.tsx`). De utnyttjar HeroUI/Tailwind för styling (t.ex. en responsiv dold/visad meny).
- **Formulärkomponenter** – För formulär som återkommer (t.ex. inmatningsfält med gemensam styling, knappar, modala dialoger för bekräftelse) har man byggt generiska komponenter eller abstraherat via HeroUI. `primitives.ts` kan innehålla exempelvis en egen `<TextInput>` komponent som wrappar `@heroui/input` men lägger till formhantering. `StatusConfirmationDialog.tsx` är en återanvändbar dialog som visas när någon ska t.ex. markera ett ärende som *Avslutat* – den tar kanske in en callback att köra om användaren bekräftar. Sådana modaler och dialoger följer ett mönster för UX – att alltid fråga om bekräftelse vid destruktiva handlingar. De är implementerade en gång och kan kallas från flera ställen (t.ex. både från ärendelistan och ärendedetaljvyn).
- **Återanvändbara listvyer** – TicketTable och CustomerTable (antas finnas) är exempel på komponenter som listar poster i en tabell med sortering och filtrering. `TicketFilters.tsx` hanterar filtreringslogik för ärendelistan (t.ex. filter per status, per typ eller sökord) ([Servicedrive-2.0/documentation/componentStructure.txt at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/documentation/componentStructure.txt#:~:text=match%20at%20L794%20TicketTable,En%20tabellkomponent%20specialiserad%20f%C3%B6r%20%C3%A4renden)). Dessa är designade att vara återanvändbara över applikationen; filterkomponenten kan användas på dashboard för snabbfiltrering eller på huvudsidan för ärenden.
- **Kontext för valt företag (Store)** – Eftersom användare kan byta vilken *Store* de arbetar med, finns *StoreSelector.tsx* som en dropdown av tillgängliga stores. Denna komponent interagerar med global state (kanske NextAuth session eller en egen React Context) för att uppdatera vilken store är “aktiv”. Tillsammans med det finns troligen en Context Provider högt upp (kanske `StoreProvider`) eller så lagras val i `UserPreference.selectedStoreId` via backend. Oavsett, *StoreSelector* utgör ett mönster för multi-tenancy: användaren kan när som helst byta kontext och därefter ska listor och data filtreras för den valda store. 
- **Rollhantering i UI** – Komponenter som `StoreManager.tsx` och `AccountSettings.tsx` finns sannolikt endast åtkomliga för Admin-roller. Ett mönster är att komponenter eller hela sidor kollar `session.user.role` och om rollen inte matchar, visas antingen inget eller så omdirigeras man. Detta är en form av *Protected Component*-mönster. I React kan man implementera en HOC eller wrapper, men här räcker det kanske med enkel logik. T.ex. `StoreManager.tsx` (för att lägga till/ta bort stores eller användare i store) visas endast för Admin, en Manager kanske inte ens ser den.
- **Dynamiska fält** – Systemet tillämpar ett designmönster för att hantera extra fält för ärenden och kunder utan att ändra databasstrukturen för varje nytt fält. Mönstret är att använda generiska JSON-fält (*dynamicFields*) i kombination med datadrivna fältspecifikationer (*TicketField* för ärenden). Komponentmässigt innebär det att gränssnittet som visar eller editerar dessa fält behöver vara generiskt. Troligen finns en komponent som tar t.ex. en lista TicketField och renderar motsvarande input-fält i formuläret för nytt ärende. `field-matcher.ts` hjälper till att mappa fältens typ (TEXT/NUMBER/DATE osv.) till rätt input-komponent och även att tolka/spara värdena i JSON-format. Detta är ett **designmönster för utbyggbarhet** – admin kan lägga till nya typer av fält i adminpanel (som skapar TicketField i DB) och därefter dyker de upp i formulären utan kodändring. En utmaning är validering – här kommer Zod (eller manual kontroll) in för att säkerställa att om ett fält är `isRequired: true`, så får inte fältet lämnas tomt. Sammanfattat är *dynamiska formulär* ett avancerat mönster som implementerats för ärenden (och kanske planerat för kundkort).
- **Konsekvent UI med HeroUI** – Genomgående följer komponenterna HeroUIs design. Ett mönster är *theming* – med next-themes kan användare byta till mörkt läge och tack vare att komponenterna i HeroUI definierats med Tailwind’s `dark:` klasser och `heroui` tema, så slår hela appen om stil. Detta är implementerat på ett ställe (troligen i `_app.tsx` med `<ThemeProvider attribute="class" defaultTheme="light">`) och alla komponenter anpassar sig därefter. Det är ett **Theming-mönster** som är konsekvent och lätt att underhålla.
- **Kodstruktur och separation** – Projektet följer en ren struktur där logik separeras från vy: *Presentations*-komponenter är fokuserade på att visa data, medan *service*-moduler (i utils/) fokuserar på att hämta/bearbeta data. Detta är ett klassiskt **Separation of Concerns**-mönster. Exempel: sökfunktionen – istället för att stoppa in hela sökalgoritmen i en API-route eller komponent, har man extraherat den till `searchService.ts`. Samma med e-postutskick som hanteras i `mail-service.ts` i stället för att ha API-koden direkt integrera med SendGrid. Detta gör koden mer testbar och modulär.
- **Tester** – Genom att inkludera tester i projektet, uppmuntras också *Testdrivet tänk*. Varje viktig funktion (ex. autentisering, API-svar) kan valideras i ett test. Att man har en `Tests/api/` mapp tyder på att man skapat tester för API-endpoints (mockat NextApiRequest/Response och kontrollerat svarskoder och databaspåverkan i en transaction som sedan rullas tillbaka, eventuellt). För komponenter med mycket logik (ex. filterkomponenten) kan enhetstester säkerställa att filtreringsfunktioner ger rätt resultat givet olika input.

## Testverktyg och testpraxis 
För att säkerställa kvaliteten används **Vitest** som testramverk, tillsammans med **React Testing Library** för komponenttester. Vitest är konfigurerat att köra tester i en JSDOM-miljö ([Servicedrive-2.0/vitest.config.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/vitest.config.ts#:~:text=test%3A%20)), vilket innebär att React-komponenter renderas på ett sätt som liknar en webbläsare. Man har ett globalt setup-script (`Tests/setupTests.ts`) där t.ex. matchers från `@testing-library/jest-dom` importeras (vilket gör att man kan skriva `expect(element).toBeInTheDocument()` etc.). 

I och med att *globals* är true behöver man inte importera `describe` och `it` i varje testfil – de är automatiskt tillgängliga ([Servicedrive-2.0/vitest.config.ts at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/vitest.config.ts#:~:text=setupFiles%3A%20,l%C3%A4gger%20global%20config%20f%C3%B6r%20tester)). Detta efterliknar Jests användning, vilket många utvecklare är vana vid. För att testa React-komponenter används Testing Librarys metoder som `render()` för att rendera komponenten, `screen.getByText`/`findByRole` för att hitta element, och sedan assertions för att kontrollera att komponenten beter sig rätt. Man kan t.ex. testa att när man klickar på status-knappen, så öppnas `StatusConfirmationDialog`-komponenten. 

För API-rutter och andra funktioner kan man genom Vitest använda rena funktionstester. T.ex. att anropa `loginRateLimiter.consume` flera gånger och förvänta sig att det kastar fel efter X + 1 försök. Eller att kalla `searchService.search("abc")` på ett seedat dataset och kontrollera att resultat innehåller förväntade poster.

Eftersom Next.js specifika delar (som `getServerSideProps`) kan vara svåra att testa direkt, fokuserar man troligen på att testa den underliggande logiken. Prisma kan konfigureras att använda en testdatabas (t.ex. SQLite i minnet) under test, så att test av databasanrop inte påverkar utvecklingsdatabasen. *node-mocks-http* hjälper att simulera Request/Response-objekt: man kan skapa ett fake-`req` med metod, body, query etc., och ett `res` som fångar upp status och data. Sedan importera en API-handler-funktion och anropa den med (req, res) och i efterhand kontrollera `res._getStatusCode()` och `res._getJSONData()` för att verifiera resultat. Denna metod gör att API-endpoints kan testas som enhet (utan att behöva köra en server). 

Projektets testpraxis verkar vara att täcka kritiska delar: autentisering (testa att fel lösenord ger error, att rätt lösenord ger token), behörighet (att skyddade API-endpoints returnerar 401 om ej inloggad – detta kan dock vara svårt att testa då middleware sköter det utanför endpointen, men man kan isolerat testa middleware-funktionen med ett mockat NextRequest utan token och se att den returnerar en redirect), samt viktiga util-funktioner (t.ex. validering av e-post, formatering av datum). Genom att använda Vitest med JSDOM testar man också **komponenternas interaktion** – t.ex. ett test kan rendera <StoreSelector> med en lista av stores i context och simulera ett användarval och sedan förvänta att active store ändras (vilket i test kan observeras via context value eller ett callback).

Att döma av struktur och verktyg har man lagt grunden för en sund testkultur, även om omfattningen av testsuite inte framgår direkt. Vitest integreras med projektets type-check, vilket innebär att även testfiler är typkontrollerade (minimerar fel i testerna själva).

---

**Sammanfattning:** Servicedrive 2.0 är ett fullständigt fullstack-projekt med en modern teknisk uppsättning. På frontend-sidan utnyttjas Next.js pages-router, React med komponent-baserad arkitektur och Tailwind/HeroUI för design; på backend-sidan Next.js API Routes med Prisma ORM kopplat till en strukturerad datamodell i Postgres. Autentisering är robust med NextAuth (credentials + JWT) och middleware-skydd, kompletterat av rollbaserad logik och planerad 2FA. Projektet är väldefinierat med tydlig kodstruktur, konfigurationsfiler för varje verktyg och testverktyg för att trygga fortsatt utveckling. Allt detta gör koden **lätt att underhålla och utöka**, vilket är viktigt när en AI-baserad utvecklare (LLM) ska ta vid och jobba vidare med projektet – all nödvändig kontext om arkitektur, designbeslut och konventioner finns nu dokumenterad. ([Servicedrive-2.0/README.md at frontier-1.0 · SimB-commits/Servicedrive-2.0 · GitHub](https://github.com/SimB-commits/Servicedrive-2.0/blob/frontier-1.0/README.md#:~:text=Technologies%20Used))